[toc]

## Problem 2.3：最后的最后

1. 不用反复弹出、加入，直接用数学运算确定弹出的值
2. 题目要求使用循环链表
   - 有一个头结点，首尾相连
   - 运行过程中需要存储previous节点，以完成删除操作

## Problem 3.4：修仙之路

1. 即找出矩阵中最长的递增路径
2. DFS搜索
   - 已经搜索过，反馈值
   - 没有搜索过，往下递归

## Problem 3.5：小木棍

### 总思路

1. 递归:状态记为`(r,m)`,`r`是剩下的木棒数目,`m`是当前正在拼的这根木棍还差的长度
2. 递归缩小规模:放上这跟棒子之后(长度为`l`)状态为`(r-1,m-l)`
3. 当`m==0`时若`r==0`则结束,否则填下一根
4. 如果不成功,回溯,撤掉这木棒再换(这里撤掉的木棒迟早会出现在后面某一根木棍中)
5. 全撤完了还不行就换下一个木棍长度

### 剪枝

1. 显然我们取的遍历木棍长度一定是总长度的因子,大于等于最长木棒小于等于总长一半
2. 从长到短放木棒，如果撤掉一跟木棒，不要再尝试和它一样长或比它更长的木棒==（现在不放，后面迟早要放；现在不行，后面也不会行）==
3. 如果回溯后发现某跟棍子的第一根棒子需要换掉，那么可以直接跳过更换第一根棒子的步骤直接拆上一根拼出来的棍子（或者换长度）
   - 我们从长往短放，现在不能放在第一个位置，后面迟早要放在第一个位置，自然也不行
   - 该剪枝最显著，因为从第一个棍子开始的递归是最繁复的，省去了最麻烦的部分
4. 如果撤完的这根是木棍上的最后一段,那么就不用试比它更短的了
   - 如果替换成更短的木棒是可行的（如`d`替换成`e+f`），那么`d`会在后面出现，将`d`和`e+f`替换也是一种方案，但是前面的尝试表明该方案不可行，矛盾

### 代码

```python
while True:
    n=int(input())
    if n==0:
        break
    lenth=list(map(int,input().split()))
    total=sum(lenth)
    lenth.sort(reverse=True)#棒子长度排序,从长到短拿木棒
    used=[0]*65#记录某个木棒是否被拿过了
    last=-1
    
    def dfs(r,m):#r是剩下的木棒数目,m是正在拼的这根木棍还差的长度
        global l
        global last
        if r==0 and m==0:#拼好结束
            return True
        if m==0:#这根棍子拼好了换下一根
            m=l
        if m==l:#这根第一个,用于剪枝2
            notstart=0
        else:
            notstart=last+1#这两个变量辅助标记上一根棒子的位置
        for i in range(notstart,n):#剪枝1,保证后续放上去的木棍都比这跟要短
            if used[i]==0 and lenth[i]<=m:
                if i>0:
                    if used[i-1]==0 and lenth[i-1]==lenth[i]:
                        continue#剪枝1,上一个木棒被撤掉了并且长度和这一根一样,这一根就不用
                used[i]=1
                last=i
                if dfs(r-1,m-lenth[i]):#递归,放上这根木棒之后能不能成功
                    return True
                else:
                    used[i]=0#回溯,撤掉这跟木棍
                    if m==l or lenth[i]==m:
                    #剪枝2:如果撤完的这根木棒是木棍的第一段,直接放弃这根;
                    #剪枝3:如果撤完的这根是棒子上的最后一段,那么就不用试比它更短的了
                        return False
        return False
```

## Problem 4.3：和为给定数

1. 左指针`i`和右指针`j`向中间夹逼

## Problem 4.5：求逆序数

1. 原理是使用二分查找的插入排序，得到“正序数对”，总数对减去正序数就是逆序数
2. ==要保证排序是稳定的，鉴于存在数字相同的情况==



